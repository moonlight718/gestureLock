手势解锁
1.用canvas画布来实现手势解锁，并将手势解锁这个封装成一个组件
2.初始化：
	（1）获取到视图的宽度用它作为画布的宽度和高度。
	（2）根据画布的宽度计算出按钮的半径，并通过半径计算出9个按钮的x坐标和y坐标，将它们存储在buttons对象中，key值用来唯一的标示这个按钮，value值是它的x,y坐标
	（3）根据buttons的坐标和半径在画布上画出9个按钮的。
	（4）为画布绑定事件
3.事件：
	（1）touchstart事件
		（a）首先获取发生事件在屏幕上的x，y坐标
		（b）判断发生事件的位置是否在9个按钮中，如果是则将此按钮放入selected中，同时将它从buttons中删除，并将isTarget设置为true，表示开始画解锁图案
	（2）touchmove事件:如果isTarget为true的话，每触发一次touchmove事件就意味着画布的一次重绘
	（3）touchend事件:重绘画布并重置isEnd值和isTarget值，表示手势密码绘制完毕
4.重绘：
	（1）首先判断目前是否为touchend调用的函数（touchend事件没有clientX和clientY），如果不是则判断当前手指触摸的坐标是否在buttons的范围中，如果在要判断当前点和上一个点中间是否有未选中的点，如果有则要选中它，然后再将当前点放入seleted中。
	（2）画出所有的按钮（包括选中的按钮和未选中的按钮）
	（3）画出选中按钮间的所有连接线
	（4）画出当前按钮和手指之间的连接线（如是touchend则不画这段连接线）
5.结束时更新显示文字：
	（1）设置密码： 通过newPassword是否为空判断当前是第一次设置密码还是第二次设置密码，如果设置密码成功将它存入localStorage中
	（2）验证密码
	将画出来的密码与password做比较看是否相同
	
6. 最开始的时候我用数组来存储已选中的按钮和未选中的按钮，但是这种方式我发现有一个bug，比如先选中了按钮1，然后再选中按钮 3，中间的按钮2将无法自动被选中。所以我用对象来存储它们，但是这样就失去了已选中按钮的顺序，所以我又开了一个数组selectedOrder来存储顺序，然后每次判断当前选中的按钮和上一个按钮中间是否后未选中的按钮，如果有则选中它。这样解决了这个bug
